# 타임 딜레이 해결

SRS tracker 툴에 비해 현재 파이썬 파일이 매우 느리게 동작하여 pypy로 돌릴지 cpp로 다시 코드를 바꿔 구현할지 고민을 했었다.  
하지만 생각보다 그 해결방법이 간단했다. 코드상에는 데이터를 불러와 연산할 수 있도록 time delay와 같은 **interval함수**가 구현되어 있었다.  
따라서 이 함수의 default 값은 100으로 약 100ms정도 delay를 주도록 설정됐는데 이 부분 값을 감소시켰더니 처리속도가 빨라졌다.  
하지만 그렇다고 0으로 하면 데이터를 불러와 연산할 수 있는 시간이 없으므로 본인의 경우 **약 30ms정도**가 적당했다. 
![image](https://user-images.githubusercontent.com/76835313/129701718-af404769-3362-4577-a104-783b93bac3eb.png)

그리고 매 프레임마다 걸리는 시간도 측정을 하였는데 interval에서 주는 시간과 프레임마다 걸리는 시간이 거의 대동소이했다. 

## setinteval 100ms 를 줬을 때
![image](https://user-images.githubusercontent.com/76835313/129702087-8c1c3f74-5a98-423c-8acb-55ee79ef6100.png)

## setinterval 30ms 를 줬을 때
![image](https://user-images.githubusercontent.com/76835313/129702233-490c3052-817d-4886-85e9-35979f8758ea.png)

## setinterval 5ms 를 줬을 때
![image](https://user-images.githubusercontent.com/76835313/129702274-3d1aa705-0315-41f9-95c1-be4967db6b7d.png)


# 프레임 당 걸리는 시간 측정
1. 먼저 전역변수로 f1 객체하나를 생성한후 초기화 시켜준다.  
![image](https://user-images.githubusercontent.com/76835313/129706977-6df91163-65e0-41ff-b474-2ef6594665b5.png)
2. 그리고 기준이 되는 함수를 정해서 중간에 시간을 한번 측정하고(f1=time.time()) 프레임을 모두 처리한후에 다시 다음프레임을 하기위해 똑같은 함수로 돌아오므로 그때 현재 측정한 시간에서 이전측정시간인 f1을 빼는 방식으로 프레임당 처리 시간을 측정하였다. 이 기준을 토대로 하여 매 프레임당 걸리는 시간을 줄이고자 코드를 변경할 때 얼마나 성능이 높아졌는지 정량적으로 확인할 수 있게됐다.
![image](https://user-images.githubusercontent.com/76835313/129707479-21773ea4-e153-4860-af34-dd68457a09c8.png)

### 결과는 바로 위 타임 딜레이 사진에서 Frame time을 확인하시면된다.




# 실습을 참고하시려면 다음을 클릭하시면 됩니다. -> [클릭](https://github.com/YSubin/V2X_repo/blob/master/Task2-1/Radar/0817.mmw_parse_script.py)  

# K-means Clustering
실시간 K-means Clustering의 경우 로그파일을 구현하는데에는 성공하였다.    
예를들어 실시간으로 받은 데이터인 X,Y 좌표를 이용하여 K-means Clustering을 진행하였는데 아래와 같다.  

## 출력된 좌표를 복사
![image](https://user-images.githubusercontent.com/76835313/129702491-088dba91-28e5-436c-a636-d31a396ec5b3.png)

## 주피터 노트북 상에서 구현
![image](https://user-images.githubusercontent.com/76835313/129702510-cf45e4f2-f956-480b-8917-549fae12becf.png)

하지만 위와같이 Warning이 뜨는것을 볼 수 있다. 이것은 주피터 노트북상에서는 호환성이좋아(뇌피셜) Warning으로 뜨고 동작은 되지만,    
파이참에서는 아예 에러가 뜨며 동작이 되지 않는다. 그래서 이 Warning을 무시하고자 아래와 같은 코드를 넣었다.   

    import warnings
    warnings.simplefilter(action="ignore", category=FutureWarning)
    
마찬가지로 주피터 노트북에서는 Warning도 없어지며 잘 됐지만 Pycharm에서는 아예 되지않았다.   

**그리고 또 한가지 문제는 K-means의 경우 Clustering을 할 개수를 미리 정하고 시작하기 떄문에 실제 자동차를 검출할때는 적합하지 않다.  
예를들어 3이라고설정하면 차가 90대 지나갈 경우 30대를 한 객체로 보는 것이다.**  


# 실습을 참고하시려면 다음을 클릭하시면 됩니다. -> [클릭](https://github.com/YSubin/V2X_repo/blob/master/Task2-1/Radar/0817.K-means%20%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81%20%EC%8B%A4%EC%8A%B5.ipynb)  

따라서 결론은 DBSCAN을 구현해야한다. 

# 다음 할일
1. DBSCAN 실시간으로 구현하기 (X,Y좌표값 받아서 실시간으로 GUI상에 나타내기. 본인은 matplotlib보다 pyqthraph가 실시간으로 하기에 가장 적합해보임.)
2. YOLOv5 파이썬 파일과 레이더 파이썬 파일 합치기.
3. YOLO 데이터 더 구축하기. (makesense.ai 사이트에서 라벨링하는게 좋을 듯 하다. 그 이유는 라벨링작업이 끝나고 파일 생성시 YOLOv5 학습에 맞도록 파일 폴더를 알맞게 생성해 주기 때문이다.) 
